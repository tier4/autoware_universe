diff --git a/control/autoware_control_command_gate/launch/control_command_gate.launch.xml b/control/autoware_control_command_gate/launch/control_command_gate.launch.xml
index 5fda443a61..44065b6df9 100644
--- a/control/autoware_control_command_gate/launch/control_command_gate.launch.xml
+++ b/control/autoware_control_command_gate/launch/control_command_gate.launch.xml
@@ -1,14 +1,26 @@
 <launch>
   <arg name="config" default="$(find-pkg-share autoware_control_command_gate)/config/default.param.yaml"/>
+  <arg name="output/control" default="/control/command/control_cmd"/>
+  <arg name="output/gear" default="/control/command/gear_cmd"/>
+  <arg name="output/turn_indicators" default="/control/command/turn_indicators_cmd"/>
+  <arg name="output/hazard_lights" default="/control/command/hazard_lights_cmd"/>
+  <arg name="inputs/main/control" default="/control/trajectory_follower/control_cmd"/>
+  // Confirm that "main" is listed in config input_names
+  <arg name="inputs/main/gear" default="/control/shift_decider/gear_cmd"/>
+  // Confirm that "main" is listed in config input_names
+  <arg name="inputs/main/hazard_lights" default="/planning/hazard_lights_cmd"/>
+  // Confirm that "main" is listed in config input_names
+  <arg name="inputs/main/turn_indicators" default="/planning/turn_indicators_cmd"/>
+  // Confirm that "main" is listed in config input_names
   <node pkg="autoware_control_command_gate" exec="control_command_gate_node">
     <param from="$(var config)"/>
-    <remap from="~/output/control" to="/control/command/control_cmd"/>
-    <remap from="~/output/gear" to="/control/command/gear_cmd"/>
-    <remap from="~/output/turn_indicators" to="/control/command/turn_indicators_cmd"/>
-    <remap from="~/output/hazard_lights" to="/control/command/hazard_lights_cmd"/>
-    <remap from="~/inputs/main/control" to="/control/trajectory_follower/control_cmd"/>
-    <remap from="~/inputs/main/gear" to="/control/shift_decider/gear_cmd"/>
-    <remap from="~/inputs/main/hazard_lights" to="/planning/hazard_lights_cmd"/>
-    <remap from="~/inputs/main/turn_indicators" to="/planning/turn_indicators_cmd"/>
+    <remap from="~/output/control" to="$(var output/control)"/>
+    <remap from="~/output/gear" to="$(var output/gear)"/>
+    <remap from="~/output/turn_indicators" to="$(var output/turn_indicators)"/>
+    <remap from="~/output/hazard_lights" to="$(var output/hazard_lights)"/>
+    <remap from="~/inputs/main/control" to="$(var inputs/main/control)"/>
+    <remap from="~/inputs/main/gear" to="$(var inputs/main/gear)"/>
+    <remap from="~/inputs/main/hazard_lights" to="$(var inputs/main/hazard_lights)"/>
+    <remap from="~/inputs/main/turn_indicators" to="$(var inputs/main/turn_indicators)"/>
   </node>
 </launch>
diff --git a/control/autoware_control_performance_analysis/README.md b/control/autoware_control_performance_analysis/README.md
index e57126b28c..d901aa26b9 100644
--- a/control/autoware_control_performance_analysis/README.md
+++ b/control/autoware_control_performance_analysis/README.md
@@ -25,13 +25,13 @@ Error acceleration calculations are made based on the velocity calculations abov
 
 ### Input topics
 
-| Name                                     | Type                                       | Description                                 |
-| ---------------------------------------- | ------------------------------------------ | ------------------------------------------- |
-| `/planning/scenario_planning/trajectory` | autoware_planning_msgs::msg::Trajectory    | Output trajectory from planning module.     |
-| `/control/command/control_cmd`           | autoware_control_msgs::msg::Control        | Output control command from control module. |
-| `/vehicle/status/steering_status`        | autoware_vehicle_msgs::msg::SteeringReport | Steering information from vehicle.          |
-| `/localization/kinematic_state`          | nav_msgs::msg::Odometry                    | Use twist from odometry.                    |
-| `/tf`                                    | tf2_msgs::msg::TFMessage                   | Extract ego pose from tf.                   |
+| Name                              | Type                                       | Description                                 |
+| --------------------------------- | ------------------------------------------ | ------------------------------------------- |
+| `/planning/trajectory`            | autoware_planning_msgs::msg::Trajectory    | Output trajectory from planning module.     |
+| `/control/command/control_cmd`    | autoware_control_msgs::msg::Control        | Output control command from control module. |
+| `/vehicle/status/steering_status` | autoware_vehicle_msgs::msg::SteeringReport | Steering information from vehicle.          |
+| `/localization/kinematic_state`   | nav_msgs::msg::Odometry                    | Use twist from odometry.                    |
+| `/tf`                             | tf2_msgs::msg::TFMessage                   | Extract ego pose from tf.                   |
 
 ### Output topics
 
diff --git a/control/autoware_control_performance_analysis/launch/control_performance_analysis.launch.xml b/control/autoware_control_performance_analysis/launch/control_performance_analysis.launch.xml
index eb479942e3..4acf49913d 100644
--- a/control/autoware_control_performance_analysis/launch/control_performance_analysis.launch.xml
+++ b/control/autoware_control_performance_analysis/launch/control_performance_analysis.launch.xml
@@ -1,6 +1,6 @@
 <launch>
   <arg name="control_performance_analysis_param_path" default="$(find-pkg-share autoware_control_performance_analysis)/config/control_performance_analysis.param.yaml"/>
-  <arg name="input/reference_trajectory" default="/planning/scenario_planning/trajectory"/>
+  <arg name="input/reference_trajectory" default="/planning/trajectory"/>
   <arg name="input/control_raw" default="/control/command/control_cmd"/>
   <arg name="input/measured_steering" default="/vehicle/status/steering_status"/>
   <arg name="input/current_odometry" default="/localization/kinematic_state"/>
diff --git a/control/autoware_control_validator/launch/control_validator.launch.xml b/control/autoware_control_validator/launch/control_validator.launch.xml
index 31c38c6995..a36d771ca8 100644
--- a/control/autoware_control_validator/launch/control_validator.launch.xml
+++ b/control/autoware_control_validator/launch/control_validator.launch.xml
@@ -1,6 +1,6 @@
 <launch>
   <arg name="control_validator_param_path" default="$(find-pkg-share autoware_control_validator)/config/control_validator.param.yaml"/>
-  <arg name="input_reference_trajectory" default="/planning/scenario_planning/trajectory"/>
+  <arg name="input_reference_trajectory" default="/planning/trajectory"/>
   <arg name="input_predicted_trajectory" default="/control/trajectory_follower/lateral/predicted_trajectory"/>
   <arg name="input_operational_mode_state" default="/api/operation_mode/state"/>
 
diff --git a/control/autoware_control_validator/src/control_validator.cpp b/control/autoware_control_validator/src/control_validator.cpp
index a2366a0961..ac6d3803eb 100644
--- a/control/autoware_control_validator/src/control_validator.cpp
+++ b/control/autoware_control_validator/src/control_validator.cpp
@@ -256,6 +256,8 @@ ControlValidator::ControlValidator(const rclcpp::NodeOptions & options)
 
   setup_parameters();
 
+  validation_filtering(validation_status_);
+
   setup_diag();
 }
 
diff --git a/control/autoware_lane_departure_checker/README.md b/control/autoware_lane_departure_checker/README.md
index 4692829e7e..a37d51cd90 100644
--- a/control/autoware_lane_departure_checker/README.md
+++ b/control/autoware_lane_departure_checker/README.md
@@ -51,7 +51,7 @@ This package includes the following features:
 - /localization/kinematic_state [`nav_msgs::msg::Odometry`]
 - /map/vector_map [`autoware_map_msgs::msg::LaneletMapBin`]
 - /planning/mission_planning/route [`autoware_planning_msgs::msg::LaneletRoute`]
-- /planning/scenario_planning/trajectory [`autoware_planning_msgs::msg::Trajectory`]
+- /planning/trajectory [`autoware_planning_msgs::msg::Trajectory`]
 - /control/trajectory_follower/predicted_trajectory [`autoware_planning_msgs::msg::Trajectory`]
 
 ### Output
diff --git a/control/autoware_lane_departure_checker/launch/lane_departure_checker.launch.xml b/control/autoware_lane_departure_checker/launch/lane_departure_checker.launch.xml
index b9f820f666..1e2eea29c2 100644
--- a/control/autoware_lane_departure_checker/launch/lane_departure_checker.launch.xml
+++ b/control/autoware_lane_departure_checker/launch/lane_departure_checker.launch.xml
@@ -2,7 +2,7 @@
   <arg name="input/odometry" default="/localization/kinematic_state"/>
   <arg name="input/lanelet_map_bin" default="/map/vector_map"/>
   <arg name="input/route" default="/planning/mission_planning/route"/>
-  <arg name="input/reference_trajectory" default="/planning/scenario_planning/trajectory"/>
+  <arg name="input/reference_trajectory" default="/planning/trajectory"/>
   <arg name="input/predicted_trajectory" default="/control/trajectory_follower/predicted_trajectory"/>
   <arg name="config_file" default="$(find-pkg-share autoware_lane_departure_checker)/config/lane_departure_checker.param.yaml"/>
 
diff --git a/control/autoware_mpc_lateral_controller/include/autoware/mpc_lateral_controller/mpc_utils.hpp b/control/autoware_mpc_lateral_controller/include/autoware/mpc_lateral_controller/mpc_utils.hpp
index 87f6c0064a..3ec67104d1 100644
--- a/control/autoware_mpc_lateral_controller/include/autoware/mpc_lateral_controller/mpc_utils.hpp
+++ b/control/autoware_mpc_lateral_controller/include/autoware/mpc_lateral_controller/mpc_utils.hpp
@@ -81,9 +81,10 @@ MPCTrajectory convertToMPCTrajectory(const Trajectory & input);
 /**
  * @brief convert the given MPCTrajectory to a Trajectory msg
  * @param [in] input MPCTrajectory to be converted
+ * @param [in] wheelbase [m] wheelbase of the vehicle
  * @return output converted Trajectory msg
  */
-Trajectory convertToAutowareTrajectory(const MPCTrajectory & input);
+Trajectory convertToAutowareTrajectory(const MPCTrajectory & input, const double wheelbase = 0.0);
 
 /**
  * @brief calculate the arc length at each point of the given trajectory
diff --git a/control/autoware_mpc_lateral_controller/src/mpc.cpp b/control/autoware_mpc_lateral_controller/src/mpc.cpp
index 5692cf5044..7a141e0e51 100644
--- a/control/autoware_mpc_lateral_controller/src/mpc.cpp
+++ b/control/autoware_mpc_lateral_controller/src/mpc.cpp
@@ -828,7 +828,8 @@ Trajectory MPC::calculatePredictedTrajectory(
   const auto clipped_trajectory =
     MPCUtils::clipTrajectoryByLength(predicted_mpc_trajectory, predicted_length);
 
-  const auto predicted_trajectory = MPCUtils::convertToAutowareTrajectory(clipped_trajectory);
+  const auto predicted_trajectory =
+    MPCUtils::convertToAutowareTrajectory(clipped_trajectory, m_vehicle_model_ptr->getWheelbase());
 
   return predicted_trajectory;
 }
diff --git a/control/autoware_mpc_lateral_controller/src/mpc_utils.cpp b/control/autoware_mpc_lateral_controller/src/mpc_utils.cpp
index f46d8e3fcb..f18727194c 100644
--- a/control/autoware_mpc_lateral_controller/src/mpc_utils.cpp
+++ b/control/autoware_mpc_lateral_controller/src/mpc_utils.cpp
@@ -275,7 +275,7 @@ MPCTrajectory convertToMPCTrajectory(const Trajectory & input)
   return output;
 }
 
-Trajectory convertToAutowareTrajectory(const MPCTrajectory & input)
+Trajectory convertToAutowareTrajectory(const MPCTrajectory & input, const double wheelbase)
 {
   Trajectory output;
   TrajectoryPoint p;
@@ -286,6 +286,11 @@ Trajectory convertToAutowareTrajectory(const MPCTrajectory & input)
     p.pose.orientation = autoware_utils::create_quaternion_from_yaw(input.yaw.at(i));
     p.longitudinal_velocity_mps =
       static_cast<decltype(p.longitudinal_velocity_mps)>(input.vx.at(i));
+    p.time_from_start =
+      rclcpp::Duration::from_seconds(input.relative_time.at(i) - input.relative_time.front());
+    if (wheelbase != 0.0) {
+      p.front_wheel_angle_rad = static_cast<float>(std::atan(input.smooth_k.at(i) * wheelbase));
+    }
     output.points.push_back(p);
     if (output.points.size() == output.points.max_size()) {
       break;
diff --git a/control/autoware_obstacle_collision_checker/launch/obstacle_collision_checker.launch.xml b/control/autoware_obstacle_collision_checker/launch/obstacle_collision_checker.launch.xml
index c2cb75415a..5e2e09a08a 100755
--- a/control/autoware_obstacle_collision_checker/launch/obstacle_collision_checker.launch.xml
+++ b/control/autoware_obstacle_collision_checker/launch/obstacle_collision_checker.launch.xml
@@ -1,7 +1,7 @@
 <launch>
   <arg name="input/lanelet_map_bin" default="/map/vector_map"/>
   <arg name="input/obstacle_pointcloud" default="/perception/obstacle_segmentation/pointcloud"/>
-  <arg name="input/reference_trajectory" default="/planning/scenario_planning/trajectory"/>
+  <arg name="input/reference_trajectory" default="/planning/trajectory"/>
   <arg name="input/predicted_trajectory" default="/control/trajectory_follower/predicted_trajectory"/>
   <arg name="input/odometry" default="/localization/kinematic_state"/>
   <arg name="config_file" default="$(find-pkg-share autoware_obstacle_collision_checker)/config/obstacle_collision_checker.param.yaml"/>
diff --git a/control/autoware_operation_mode_transition_manager/README.md b/control/autoware_operation_mode_transition_manager/README.md
index bd217dc01c..47ecd79e9f 100644
--- a/control/autoware_operation_mode_transition_manager/README.md
+++ b/control/autoware_operation_mode_transition_manager/README.md
@@ -60,7 +60,7 @@ For the transition availability/completion check:
 
 - /control/command/control_cmd [`autoware_control_msgs/msg/Control`]: vehicle control signal
 - /localization/kinematic_state [`nav_msgs/msg/Odometry`]: ego vehicle state
-- /planning/scenario_planning/trajectory [`autoware_planning_msgs/msg/Trajectory`]: planning trajectory
+- /planning/trajectory [`autoware_planning_msgs/msg/Trajectory`]: planning trajectory
 - /vehicle/status/control_mode [`autoware_vehicle_msgs/msg/ControlModeReport`]: vehicle control mode (autonomous/manual)
 - /control/vehicle_cmd_gate/operation_mode [`autoware_adapi_v1_msgs/msg/OperationModeState`]: the operation mode in the `vehicle_cmd_gate`. (To be removed)
 
diff --git a/control/autoware_operation_mode_transition_manager/launch/autonomous_mode_transition_flag_node.launch.xml b/control/autoware_operation_mode_transition_manager/launch/autonomous_mode_transition_flag_node.launch.xml
index 9866cad23b..8385571c55 100644
--- a/control/autoware_operation_mode_transition_manager/launch/autonomous_mode_transition_flag_node.launch.xml
+++ b/control/autoware_operation_mode_transition_manager/launch/autonomous_mode_transition_flag_node.launch.xml
@@ -11,7 +11,7 @@
     <!-- rename input topics -->
     <remap from="kinematics" to="/localization/kinematic_state"/>
     <remap from="steering" to="/vehicle/status/steering_status"/>
-    <remap from="trajectory" to="/planning/scenario_planning/trajectory"/>
+    <remap from="trajectory" to="/planning/trajectory"/>
     <remap from="control_cmd" to="/control/command/control_cmd"/>
     <remap from="control_mode_report" to="/vehicle/status/control_mode"/>
     <remap from="gate_operation_mode" to="/control/vehicle_cmd_gate/operation_mode"/>
diff --git a/control/autoware_operation_mode_transition_manager/launch/operation_mode_transition_manager.launch.xml b/control/autoware_operation_mode_transition_manager/launch/operation_mode_transition_manager.launch.xml
index 700228b8af..a7c5fb77c2 100644
--- a/control/autoware_operation_mode_transition_manager/launch/operation_mode_transition_manager.launch.xml
+++ b/control/autoware_operation_mode_transition_manager/launch/operation_mode_transition_manager.launch.xml
@@ -11,7 +11,7 @@
     <!-- rename input topics -->
     <remap from="kinematics" to="/localization/kinematic_state"/>
     <remap from="steering" to="/vehicle/status/steering_status"/>
-    <remap from="trajectory" to="/planning/scenario_planning/trajectory"/>
+    <remap from="trajectory" to="/planning/trajectory"/>
     <remap from="control_cmd" to="/control/command/control_cmd"/>
     <remap from="control_mode_report" to="/vehicle/status/control_mode"/>
     <remap from="gate_operation_mode" to="/control/vehicle_cmd_gate/operation_mode"/>
diff --git a/control/autoware_operation_mode_transition_manager/src/state.cpp b/control/autoware_operation_mode_transition_manager/src/state.cpp
index edc6431ba2..0de9d5f3b7 100644
--- a/control/autoware_operation_mode_transition_manager/src/state.cpp
+++ b/control/autoware_operation_mode_transition_manager/src/state.cpp
@@ -223,12 +223,6 @@ bool AutonomousMode::isModeChangeAvailable(const InputData & input_data)
   const auto & trajectory = input_data.trajectory.value();
   const auto & trajectory_follower_control_cmd = input_data.trajectory_follower_control_cmd.value();
   const auto & control_cmd = input_data.control_cmd.value();
-
-  if (!check_engage_condition_) {
-    setAllOk(debug_info_);
-    return true;
-  }
-
   const auto current_speed = kinematics.twist.twist.linear.x;
   const auto target_control_speed = control_cmd.longitudinal.velocity;
   const auto & param = engage_acceptable_param_;
@@ -242,6 +236,11 @@ bool AutonomousMode::isModeChangeAvailable(const InputData & input_data)
     return false;
   }
 
+  if (!check_engage_condition_) {
+    setAllOk(debug_info_);
+    return true;
+  }
+
   if (trajectory.points.size() < 2) {
     RCLCPP_WARN_SKIPFIRST_THROTTLE(
       logger_, *clock_, 5000, "Engage unavailable: trajectory size must be > 2");
diff --git a/control/autoware_predicted_path_checker/launch/predicted_path_checker.launch.xml b/control/autoware_predicted_path_checker/launch/predicted_path_checker.launch.xml
index b0b8b385e7..f5e4aad0b8 100755
--- a/control/autoware_predicted_path_checker/launch/predicted_path_checker.launch.xml
+++ b/control/autoware_predicted_path_checker/launch/predicted_path_checker.launch.xml
@@ -1,6 +1,6 @@
 <launch>
   <arg name="input/objects" default="/perception/object_recognition/objects"/>
-  <arg name="input/reference_trajectory" default="/planning/scenario_planning/trajectory"/>
+  <arg name="input/reference_trajectory" default="/planning/trajectory"/>
   <arg name="input/predicted_trajectory" default="/control/trajectory_follower/lateral/predicted_trajectory"/>
   <arg name="input/odometry" default="/localization/kinematic_state"/>
   <arg name="input/current_accel" default="/localization/acceleration"/>
diff --git a/control/autoware_pure_pursuit/launch/pure_pursuit.launch.xml b/control/autoware_pure_pursuit/launch/pure_pursuit.launch.xml
index 8d69cf3a7a..574bb82494 100644
--- a/control/autoware_pure_pursuit/launch/pure_pursuit.launch.xml
+++ b/control/autoware_pure_pursuit/launch/pure_pursuit.launch.xml
@@ -1,7 +1,7 @@
 <launch>
   <arg name="pure_pursuit_param_path" default="$(find-pkg-share autoware_pure_pursuit)/config/pure_pursuit.param.yaml"/>
 
-  <arg name="input/reference_trajectory" default="/planning/scenario_planning/trajectory"/>
+  <arg name="input/reference_trajectory" default="/planning/trajectory"/>
   <arg name="input/current_odometry" default="/localization/kinematic_state"/>
   <arg name="output/control_raw" default="lateral/control_cmd"/>
 
diff --git a/control/autoware_smart_mpc_trajectory_follower/scripts/pympc_trajectory_follower.py b/control/autoware_smart_mpc_trajectory_follower/scripts/pympc_trajectory_follower.py
index 104261866c..46b87667d3 100755
--- a/control/autoware_smart_mpc_trajectory_follower/scripts/pympc_trajectory_follower.py
+++ b/control/autoware_smart_mpc_trajectory_follower/scripts/pympc_trajectory_follower.py
@@ -79,7 +79,7 @@ class PyMPCTrajectoryFollower(Node):
 
         self.sub_trajectory_ = self.create_subscription(
             Trajectory,
-            "/planning/scenario_planning/trajectory",
+            "/planning/trajectory",
             self.onTrajectory,
             1,
         )
diff --git a/control/autoware_trajectory_follower_node/launch/simple_trajectory_follower.launch.xml b/control/autoware_trajectory_follower_node/launch/simple_trajectory_follower.launch.xml
index 521638dd7a..11199837b7 100644
--- a/control/autoware_trajectory_follower_node/launch/simple_trajectory_follower.launch.xml
+++ b/control/autoware_trajectory_follower_node/launch/simple_trajectory_follower.launch.xml
@@ -8,7 +8,7 @@
     <param from="$(find-pkg-share autoware_trajectory_follower_node)/config/simple_trajectory_follower.param.yaml" allow_substs="true"/>
 
     <remap from="input/kinematics" to="/localization/kinematic_state"/>
-    <remap from="input/trajectory" to="/planning/scenario_planning/trajectory"/>
+    <remap from="input/trajectory" to="/planning/trajectory"/>
     <remap from="output/control_cmd" to="/vehicle/command/manual_control_cmd"/>
   </node>
 </launch>
diff --git a/control/autoware_vehicle_cmd_gate/README.md b/control/autoware_vehicle_cmd_gate/README.md
index bbefc9e79c..693793dc12 100644
--- a/control/autoware_vehicle_cmd_gate/README.md
+++ b/control/autoware_vehicle_cmd_gate/README.md
@@ -44,30 +44,57 @@
 
 ## Parameters
 
-| Parameter                                   | Type     | Description                                                                                                                                                                                 |
-| ------------------------------------------- | -------- | ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
-| `update_period`                             | double   | update period                                                                                                                                                                               |
-| `use_emergency_handling`                    | bool     | true when emergency handler is used                                                                                                                                                         |
-| `check_external_emergency_heartbeat`        | bool     | true when checking heartbeat for emergency stop                                                                                                                                             |
-| `system_emergency_heartbeat_timeout`        | double   | timeout for system emergency                                                                                                                                                                |
-| `external_emergency_stop_heartbeat_timeout` | double   | timeout for external emergency                                                                                                                                                              |
-| `filter_activated_count_threshold`          | int      | threshold for filter activation                                                                                                                                                             |
-| `filter_activated_velocity_threshold`       | double   | velocity threshold for filter activation                                                                                                                                                    |
-| `stop_hold_acceleration`                    | double   | longitudinal acceleration cmd when vehicle should stop                                                                                                                                      |
-| `emergency_acceleration`                    | double   | longitudinal acceleration cmd when vehicle stop with emergency                                                                                                                              |
-| `moderate_stop_service_acceleration`        | double   | longitudinal acceleration cmd when vehicle stop with moderate stop service                                                                                                                  |
-| `nominal.vel_lim`                           | double   | limit of longitudinal velocity (activated in AUTONOMOUS operation mode)                                                                                                                     |
-| `nominal.reference_speed_point`             | <double> | velocity point used as a reference when calculate control command limit (activated in AUTONOMOUS operation mode). The size of this array must be equivalent to the size of the limit array. |
-| `nominal.lon_acc_lim`                       | <double> | array of limits of longitudinal acceleration (activated in AUTONOMOUS operation mode)                                                                                                       |
-| `nominal.lon_jerk_lim`                      | <double> | array of limits of longitudinal jerk (activated in AUTONOMOUS operation mode)                                                                                                               |
-| `nominal.lat_acc_lim`                       | <double> | array of limits of lateral acceleration (activated in AUTONOMOUS operation mode)                                                                                                            |
-| `nominal.lat_jerk_lim`                      | <double> | array of limits of lateral jerk (activated in AUTONOMOUS operation mode)                                                                                                                    |
-| `on_transition.vel_lim`                     | double   | limit of longitudinal velocity (activated in TRANSITION operation mode)                                                                                                                     |
-| `on_transition.reference_speed_point`       | <double> | velocity point used as a reference when calculate control command limit (activated in TRANSITION operation mode). The size of this array must be equivalent to the size of the limit array. |
-| `on_transition.lon_acc_lim`                 | <double> | array of limits of longitudinal acceleration (activated in TRANSITION operation mode)                                                                                                       |
-| `on_transition.lon_jerk_lim`                | <double> | array of limits of longitudinal jerk (activated in TRANSITION operation mode)                                                                                                               |
-| `on_transition.lat_acc_lim`                 | <double> | array of limits of lateral acceleration (activated in TRANSITION operation mode)                                                                                                            |
-| `on_transition.lat_jerk_lim`                | <double> | array of limits of lateral jerk (activated in TRANSITION operation mode)                                                                                                                    |
+| Parameter                                             | Type     | Description                                                                                                                                                                                 |
+| ----------------------------------------------------- | -------- | ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
+| `update_period`                                       | double   | update period                                                                                                                                                                               |
+| `use_emergency_handling`                              | bool     | true when emergency handler is used                                                                                                                                                         |
+| `check_external_emergency_heartbeat`                  | bool     | true when checking heartbeat for emergency stop                                                                                                                                             |
+| `system_emergency_heartbeat_timeout`                  | double   | timeout for system emergency                                                                                                                                                                |
+| `external_emergency_stop_heartbeat_timeout`           | double   | timeout for external emergency                                                                                                                                                              |
+| `filter_activated_count_threshold`                    | int      | threshold for filter activation                                                                                                                                                             |
+| `filter_activated_velocity_threshold`                 | double   | velocity threshold for filter activation                                                                                                                                                    |
+| `stop_hold_acceleration`                              | double   | longitudinal acceleration cmd when vehicle should stop                                                                                                                                      |
+| `emergency_acceleration`                              | double   | longitudinal acceleration cmd when vehicle stop with emergency                                                                                                                              |
+| `moderate_stop_service_acceleration`                  | double   | longitudinal acceleration cmd when vehicle stop with moderate stop service                                                                                                                  |
+| `nominal.vel_lim`                                     | double   | limit of longitudinal velocity (activated in AUTONOMOUS operation mode)                                                                                                                     |
+| `nominal.reference_speed_points`                      | <double> | velocity point used as a reference when calculate control command limit (activated in AUTONOMOUS operation mode). The size of this array must be equivalent to the size of the limit array. |
+| `nominal.lon_acc_lim_for_lon_vel`                     | <double> | array of limits for longitudinal acceleration (activated in AUTONOMOUS operation mode)                                                                                                      |
+| `nominal.lon_jerk_lim_for_lon_acc`                    | <double> | array of limits for longitudinal jerk (activated in AUTONOMOUS operation mode)                                                                                                              |
+| `nominal.lat_acc_lim_for_steer_cmd`                   | <double> | array of limits for lateral acceleration (activated in AUTONOMOUS operation mode)                                                                                                           |
+| `nominal.lat_jerk_lim_for_steer_cmd`                  | <double> | array of limits for lateral jerk (activated in AUTONOMOUS operation mode)                                                                                                                   |
+| `nominal.steer_cmd_lim`                               | <double> | array of limits for steering angle (activated in AUTONOMOUS operation mode)                                                                                                                 |
+| `nominal.steer_rate_lim_for_steer_cmd`                | <double> | array of limits for command steering rate (activated in AUTONOMOUS operation mode)                                                                                                          |
+| `nominal.lat_jerk_lim_for_steer_rate`                 | double   | limit for lateral jerk constraint on steering rate (activated in AUTONOMOUS operation mode)                                                                                                 |
+| `nominal.steer_cmd_diff_lim_from_current_steer`       | <double> | array of limits for difference between current and command steering angle (activated in AUTONOMOUS operation mode)                                                                          |
+| `on_transition.vel_lim`                               | double   | limit of longitudinal velocity (activated in TRANSITION operation mode)                                                                                                                     |
+| `on_transition.reference_speed_points`                | <double> | velocity point used as a reference when calculate control command limit (activated in TRANSITION operation mode). The size of this array must be equivalent to the size of the limit array. |
+| `on_transition.lon_acc_lim_for_lon_vel`               | <double> | array of limits for longitudinal acceleration (activated in TRANSITION operation mode)                                                                                                      |
+| `on_transition.lon_jerk_lim_for_lon_acc`              | <double> | array of limits for longitudinal jerk (activated in TRANSITION operation mode)                                                                                                              |
+| `on_transition.lat_acc_lim_for_steer_cmd`             | <double> | array of limits for lateral acceleration (activated in TRANSITION operation mode)                                                                                                           |
+| `on_transition.lat_jerk_lim_for_steer_cmd`            | <double> | array of limits for lateral jerk (activated in TRANSITION operation mode)                                                                                                                   |
+| `on_transition.steer_cmd_lim`                         | <double> | array of limits for steering angle (activated in TRANSITION operation mode)                                                                                                                 |
+| `on_transition.steer_rate_lim_for_steer_cmd`          | <double> | array of limits for command steering rate (activated in TRANSITION operation mode)                                                                                                          |
+| `on_transition.lat_jerk_lim_for_steer_rate`           | double   | limit for lateral jerk constraint on steering rate (activated in TRANSITION operation mode)                                                                                                 |
+| `on_transition.steer_cmd_diff_lim_from_current_steer` | <double> | array of limits for difference between current and command steering angle (activated in TRANSITION operation mode)                                                                          |
+
+### Parameter Naming Convention
+
+The parameters follow specific naming patterns to clearly distinguish between different types of constraints and their relationships:
+
+#### Pattern 1: `[constraint]_lim_for_[target]`
+
+- **Format**: `[physical_constraint]_lim_for_[controlled_variable]`
+- **Description**: Defines limits based on physical constraints (acceleration, jerk, etc.) applied to control variables
+
+#### Pattern 2: `[target]_[constraint]_lim_from_[reference]`
+
+- **Format**: `[controlled_variable]_[constraint_type]_lim_from_[reference_variable]`
+- **Description**: Defines limits on the difference or deviation of a control variable from a reference value
+
+#### Pattern 3: `[target]_lim`
+
+- **Format**: `[controlled_variable]_lim`
+- **Description**: Defines absolute limits for control variables
 
 ## Filter function
 
diff --git a/control/autoware_vehicle_cmd_gate/config/vehicle_cmd_gate.param.yaml b/control/autoware_vehicle_cmd_gate/config/vehicle_cmd_gate.param.yaml
index 8b11cdb85a..ec230913b5 100644
--- a/control/autoware_vehicle_cmd_gate/config/vehicle_cmd_gate.param.yaml
+++ b/control/autoware_vehicle_cmd_gate/config/vehicle_cmd_gate.param.yaml
@@ -15,20 +15,22 @@
     nominal:
       vel_lim: 25.0
       reference_speed_points: [0.1, 0.3, 20.0, 30.0]
-      steer_lim: [1.0, 1.0, 1.0, 0.8]
-      steer_rate_lim: [1.0, 1.0, 1.0, 0.8]
-      lon_acc_lim: [5.0, 5.0, 5.0, 4.0]
-      lon_jerk_lim: [80.0, 5.0, 5.0, 4.0] # The first element is required for quick pedal changes when stopping and starting.
-      lat_acc_lim: [5.0, 5.0, 5.0, 4.0]
-      lat_jerk_lim: [7.0, 7.0, 7.0, 6.0]
-      actual_steer_diff_lim: [1.0, 1.0, 1.0, 0.8]
+      steer_cmd_lim: [1.0, 1.0, 1.0, 0.8]
+      steer_rate_lim_for_steer_cmd: [1.0, 1.0, 1.0, 0.8]
+      lon_acc_lim_for_lon_vel: [5.0, 5.0, 5.0, 4.0]
+      lon_jerk_lim_for_lon_acc: [80.0, 5.0, 5.0, 4.0]  # The first element is required for quick pedal changes when stopping and starting.
+      lat_acc_lim_for_steer_cmd: [5.0, 5.0, 5.0, 4.0]
+      lat_jerk_lim_for_steer_cmd: [7.0, 7.0, 7.0, 6.0]
+      lat_jerk_lim_for_steer_rate: 10.0
+      steer_cmd_diff_lim_from_current_steer: [1.0, 1.0, 1.0, 0.8]
     on_transition:
       vel_lim: 50.0
       reference_speed_points: [20.0, 30.0]
-      steer_lim: [1.0, 0.8]
-      steer_rate_lim: [1.0, 0.8]
-      lon_acc_lim: [1.0, 0.9]
-      lon_jerk_lim: [0.5, 0.4]
-      lat_acc_lim: [2.0, 1.8]
-      lat_jerk_lim: [7.0, 6.0]
-      actual_steer_diff_lim: [1.0, 0.8]
+      steer_cmd_lim: [1.0, 0.8]
+      steer_rate_lim_for_steer_cmd: [1.0, 0.8]
+      lon_acc_lim_for_lon_vel: [1.0, 0.9]
+      lon_jerk_lim_for_lon_acc: [0.5, 0.4]
+      lat_acc_lim_for_steer_cmd: [2.0, 1.8]
+      lat_jerk_lim_for_steer_cmd: [7.0, 6.0]
+      lat_jerk_lim_for_steer_rate: 10.0
+      steer_cmd_diff_lim_from_current_steer: [1.0, 0.8]
diff --git a/control/autoware_vehicle_cmd_gate/schema/vehicle_cmd_gate.json b/control/autoware_vehicle_cmd_gate/schema/vehicle_cmd_gate.json
index 983a001922..d57f85856a 100644
--- a/control/autoware_vehicle_cmd_gate/schema/vehicle_cmd_gate.json
+++ b/control/autoware_vehicle_cmd_gate/schema/vehicle_cmd_gate.json
@@ -46,30 +46,116 @@
           "default": 25.0,
           "description": "limit of longitudinal velocity (activated in AUTONOMOUS operation mode)."
         },
-        "nominal.lon_acc_lim": {
-          "type": "number",
-          "default": 5.0,
-          "description": "limit of longitudinal acceleration (activated in AUTONOMOUS operation mode)."
+        "nominal.reference_speed_points": {
+          "type": "array",
+          "items": { "type": "number" },
+          "default": [0.1, 0.3, 20.0, 30.0],
+          "description": "velocity point used as a reference when calculate control command limit (activated in AUTONOMOUS operation mode)."
         },
-        "nominal.lon_jerk_lim": {
-          "type": "number",
-          "default": 5.0,
-          "description": "limit of longitudinal jerk (activated in AUTONOMOUS operation mode)."
+        "nominal.steer_cmd_lim": {
+          "type": "array",
+          "items": { "type": "number" },
+          "default": [1.0, 1.0, 1.0, 0.8],
+          "description": "array of limits for steering angle (activated in AUTONOMOUS operation mode)."
+        },
+        "nominal.lon_acc_lim_for_lon_vel": {
+          "type": "array",
+          "items": { "type": "number" },
+          "default": [5.0, 5.0, 5.0, 4.0],
+          "description": "array of limits for longitudinal acceleration (activated in AUTONOMOUS operation mode)."
+        },
+        "nominal.lon_jerk_lim_for_lon_acc": {
+          "type": "array",
+          "items": { "type": "number" },
+          "default": [80.0, 5.0, 5.0, 4.0],
+          "description": "array of limits for longitudinal jerk (activated in AUTONOMOUS operation mode)."
+        },
+        "nominal.lat_acc_lim_for_steer_cmd": {
+          "type": "array",
+          "items": { "type": "number" },
+          "default": [5.0, 5.0, 5.0, 4.0],
+          "description": "array of limits for lateral acceleration (activated in AUTONOMOUS operation mode)."
         },
-        "nominal.lat_acc_lim": {
+        "nominal.lat_jerk_lim_for_steer_cmd": {
+          "type": "array",
+          "items": { "type": "number" },
+          "default": [7.0, 7.0, 7.0, 6.0],
+          "description": "array of limits for lateral jerk (activated in AUTONOMOUS operation mode)."
+        },
+        "nominal.lat_jerk_lim_for_steer_rate": {
           "type": "number",
-          "default": 5.0,
-          "description": "limit of lateral acceleration (activated in AUTONOMOUS operation mode)."
+          "default": 10.0,
+          "description": "limit for lateral jerk constraint on steering rate (activated in AUTONOMOUS operation mode)."
+        },
+        "nominal.steer_rate_lim_for_steer_cmd": {
+          "type": "array",
+          "items": { "type": "number" },
+          "default": [1.0, 1.0, 1.0, 0.8],
+          "description": "array of limits for command steering rate (activated in AUTONOMOUS operation mode)."
+        },
+        "nominal.steer_cmd_diff_lim_from_current_steer": {
+          "type": "array",
+          "items": { "type": "number" },
+          "default": [1.0, 1.0, 1.0, 0.8],
+          "description": "array of limits for difference between current and command steering angle (activated in AUTONOMOUS operation mode)."
         },
-        "nominal.lat_jerk_lim": {
+        "on_transition.vel_lim": {
           "type": "number",
-          "default": 5.0,
-          "description": "limit of lateral jerk (activated in AUTONOMOUS operation mode)."
+          "default": 50.0,
+          "description": "limit of longitudinal velocity (activated in TRANSITION operation mode)."
         },
-        "nominal.actual_steer_diff_lim": {
+        "on_transition.reference_speed_points": {
+          "type": "array",
+          "items": { "type": "number" },
+          "default": [20.0, 30.0],
+          "description": "velocity point used as a reference when calculate control command limit (activated in TRANSITION operation mode)."
+        },
+        "on_transition.steer_cmd_lim": {
+          "type": "array",
+          "items": { "type": "number" },
+          "default": [1.0, 0.8],
+          "description": "array of limits for steering angle (activated in TRANSITION operation mode)."
+        },
+        "on_transition.lon_acc_lim_for_lon_vel": {
+          "type": "array",
+          "items": { "type": "number" },
+          "default": [1.0, 0.9],
+          "description": "array of limits for longitudinal acceleration (activated in TRANSITION operation mode)."
+        },
+        "on_transition.lon_jerk_lim_for_lon_acc": {
+          "type": "array",
+          "items": { "type": "number" },
+          "default": [0.5, 0.4],
+          "description": "array of limits for longitudinal jerk (activated in TRANSITION operation mode)."
+        },
+        "on_transition.lat_acc_lim_for_steer_cmd": {
+          "type": "array",
+          "items": { "type": "number" },
+          "default": [2.0, 1.8],
+          "description": "array of limits for lateral acceleration (activated in TRANSITION operation mode)."
+        },
+        "on_transition.lat_jerk_lim_for_steer_cmd": {
+          "type": "array",
+          "items": { "type": "number" },
+          "default": [7.0, 6.0],
+          "description": "array of limits for lateral jerk (activated in TRANSITION operation mode)."
+        },
+        "on_transition.lat_jerk_lim_for_steer_rate": {
           "type": "number",
-          "default": 1.0,
-          "description": "limit of actual steer diff (activated in AUTONOMOUS operation mode)."
+          "default": 8.0,
+          "description": "limit for lateral jerk constraint on steering rate (activated in TRANSITION operation mode)."
+        },
+        "on_transition.steer_rate_lim_for_steer_cmd": {
+          "type": "array",
+          "items": { "type": "number" },
+          "default": [1.0, 0.8],
+          "description": "array of limits for command steering rate (activated in TRANSITION operation mode)."
+        },
+        "on_transition.steer_cmd_diff_lim_from_current_steer": {
+          "type": "array",
+          "items": { "type": "number" },
+          "default": [1.0, 0.8],
+          "description": "array of limits for difference between current and command steering angle (activated in TRANSITION operation mode)."
         }
       },
       "required": [
@@ -81,11 +167,25 @@
         "stop_hold_acceleration",
         "emergency_acceleration",
         "nominal.vel_lim",
-        "nominal.lon_acc_lim",
-        "nominal.lon_jerk_lim",
-        "nominal.lat_acc_lim",
-        "nominal.lat_jerk_lim",
-        "nominal.actual_steer_diff_lim"
+        "nominal.reference_speed_points",
+        "nominal.steer_cmd_lim",
+        "nominal.lon_acc_lim_for_lon_vel",
+        "nominal.lon_jerk_lim_for_lon_acc",
+        "nominal.lat_acc_lim_for_steer_cmd",
+        "nominal.lat_jerk_lim_for_steer_cmd",
+        "nominal.lat_jerk_lim_for_steer_rate",
+        "nominal.steer_rate_lim_for_steer_cmd",
+        "nominal.steer_cmd_diff_lim_from_current_steer",
+        "on_transition.vel_lim",
+        "on_transition.reference_speed_points",
+        "on_transition.steer_cmd_lim",
+        "on_transition.lon_acc_lim_for_lon_vel",
+        "on_transition.lon_jerk_lim_for_lon_acc",
+        "on_transition.lat_acc_lim_for_steer_cmd",
+        "on_transition.lat_jerk_lim_for_steer_cmd",
+        "on_transition.lat_jerk_lim_for_steer_rate",
+        "on_transition.steer_rate_lim_for_steer_cmd",
+        "on_transition.steer_cmd_diff_lim_from_current_steer"
       ]
     }
   },
diff --git a/control/autoware_vehicle_cmd_gate/src/vehicle_cmd_filter.cpp b/control/autoware_vehicle_cmd_gate/src/vehicle_cmd_filter.cpp
index 94f093ff67..20247f9784 100644
--- a/control/autoware_vehicle_cmd_gate/src/vehicle_cmd_filter.cpp
+++ b/control/autoware_vehicle_cmd_gate/src/vehicle_cmd_filter.cpp
@@ -29,9 +29,10 @@ bool VehicleCmdFilter::setParameterWithValidation(const VehicleCmdFilterParam &
 {
   const auto s = p.reference_speed_points.size();
   if (
-    p.lon_acc_lim.size() != s || p.lon_jerk_lim.size() != s || p.lat_acc_lim.size() != s ||
-    p.lat_jerk_lim.size() != s || p.actual_steer_diff_lim.size() != s || p.steer_lim.size() != s ||
-    p.steer_rate_lim.size() != s) {
+    p.lon_acc_lim_for_lon_vel.size() != s || p.lon_jerk_lim_for_lon_acc.size() != s ||
+    p.lat_acc_lim_for_steer_cmd.size() != s || p.lat_jerk_lim_for_steer_cmd.size() != s ||
+    p.steer_cmd_diff_lim_from_current_steer.size() != s || p.steer_cmd_lim.size() != s ||
+    p.steer_rate_lim_for_steer_cmd.size() != s) {
     std::cerr << "VehicleCmdFilter::setParam() There is a size mismatch in the parameter. "
                  "Parameter initialization failed."
               << std::endl;
@@ -62,21 +63,23 @@ void VehicleCmdFilter::limitLongitudinalWithVel(Control & input) const
 
 void VehicleCmdFilter::limitLongitudinalWithAcc(const double dt, Control & input) const
 {
-  const auto lon_acc_lim = getLonAccLim();
+  const auto lon_acc_lim_for_lon_vel = getLonAccLimForLonVel();
   input.longitudinal.acceleration = std::max(
-    std::min(static_cast<double>(input.longitudinal.acceleration), lon_acc_lim), -lon_acc_lim);
-  input.longitudinal.velocity =
-    limitDiff(input.longitudinal.velocity, prev_cmd_.longitudinal.velocity, lon_acc_lim * dt);
+    std::min(static_cast<double>(input.longitudinal.acceleration), lon_acc_lim_for_lon_vel),
+    -lon_acc_lim_for_lon_vel);
+  input.longitudinal.velocity = limitDiff(
+    input.longitudinal.velocity, prev_cmd_.longitudinal.velocity, lon_acc_lim_for_lon_vel * dt);
 }
 
-void VehicleCmdFilter::VehicleCmdFilter::limitLongitudinalWithJerk(
-  const double dt, Control & input) const
+void VehicleCmdFilter::limitLongitudinalWithJerk(const double dt, Control & input) const
 {
-  const auto lon_jerk_lim = getLonJerkLim();
+  const auto lon_jerk_lim_for_lon_acc = getLonJerkLimForLonAcc();
   input.longitudinal.acceleration = limitDiff(
-    input.longitudinal.acceleration, prev_cmd_.longitudinal.acceleration, lon_jerk_lim * dt);
-  input.longitudinal.jerk =
-    std::clamp(static_cast<double>(input.longitudinal.jerk), -lon_jerk_lim, lon_jerk_lim);
+    input.longitudinal.acceleration, prev_cmd_.longitudinal.acceleration,
+    lon_jerk_lim_for_lon_acc * dt);
+  input.longitudinal.jerk = std::clamp(
+    static_cast<double>(input.longitudinal.jerk), -lon_jerk_lim_for_lon_acc,
+    lon_jerk_lim_for_lon_acc);
 }
 
 // Use ego vehicle speed (not speed command) for the lateral acceleration calculation, otherwise the
@@ -84,12 +87,12 @@ void VehicleCmdFilter::VehicleCmdFilter::limitLongitudinalWithJerk(
 void VehicleCmdFilter::limitLateralWithLatAcc(
   [[maybe_unused]] const double dt, Control & input) const
 {
-  const auto lat_acc_lim = getLatAccLim();
+  const auto lat_acc_lim_for_steer_cmd = getLatAccLimForSteerCmd();
 
   double latacc = calcLatAcc(input, current_speed_);
-  if (std::fabs(latacc) > lat_acc_lim) {
+  if (std::fabs(latacc) > lat_acc_lim_for_steer_cmd) {
     double v_sq = std::max(static_cast<double>(current_speed_ * current_speed_), 0.001);
-    double steer_lim = std::atan(lat_acc_lim * param_.wheel_base / v_sq);
+    double steer_lim = std::atan(lat_acc_lim_for_steer_cmd * param_.wheel_base / v_sq);
     input.lateral.steering_tire_angle = latacc > 0.0 ? steer_lim : -steer_lim;
   }
 }
@@ -101,10 +104,10 @@ void VehicleCmdFilter::limitLateralWithLatJerk(const double dt, Control & input)
   double curr_latacc = calcLatAcc(input, current_speed_);
   double prev_latacc = calcLatAcc(prev_cmd_, current_speed_);
 
-  const auto lat_jerk_lim = getLatJerkLim();
+  const auto lat_jerk_lim_for_steer_cmd = getLatJerkLimForSteerCmd();
 
-  const double latacc_max = prev_latacc + lat_jerk_lim * dt;
-  const double latacc_min = prev_latacc - lat_jerk_lim * dt;
+  const double latacc_max = prev_latacc + lat_jerk_lim_for_steer_cmd * dt;
+  const double latacc_min = prev_latacc - lat_jerk_lim_for_steer_cmd * dt;
 
   if (curr_latacc > latacc_max) {
     input.lateral.steering_tire_angle = calcSteerFromLatacc(current_speed_, latacc_max);
@@ -115,42 +118,60 @@ void VehicleCmdFilter::limitLateralWithLatJerk(const double dt, Control & input)
 
 void VehicleCmdFilter::limitActualSteerDiff(const double current_steer_angle, Control & input) const
 {
-  const auto actual_steer_diff_lim = getSteerDiffLim();
+  const auto steer_cmd_diff_lim_from_current_steer = getSteerCmdDiffLimFromCurrentSteer();
 
   auto ds = input.lateral.steering_tire_angle - current_steer_angle;
-  ds = std::clamp(ds, -actual_steer_diff_lim, actual_steer_diff_lim);
+  ds =
+    std::clamp(ds, -steer_cmd_diff_lim_from_current_steer, steer_cmd_diff_lim_from_current_steer);
   input.lateral.steering_tire_angle = current_steer_angle + ds;
 }
 
 void VehicleCmdFilter::limitLateralSteer(Control & input) const
 {
-  float steer_limit = std::abs(getSteerLim());
+  float steer_cmd_limit = std::abs(getSteerCmdLim());
 
   // TODO(Horibe): support steering greater than PI/2. Now the lateral acceleration
   // calculation does not support bigger steering value than PI/2 due to tan/atan calculation.
-  if (steer_limit > M_PI_2f) {
+  if (steer_cmd_limit > M_PI_2f) {
     std::cerr << "[vehicle_Cmd_gate] limitLateralSteer(): steering limit is set to pi/2 since the "
                  "current filtering logic can not handle the steering larger than pi/2. Please "
                  "check the steering angle limit."
               << std::endl;
 
-    steer_limit = M_PI_2f;
+    steer_cmd_limit = M_PI_2f;
   }
 
   input.lateral.steering_tire_angle =
-    std::clamp(input.lateral.steering_tire_angle, -steer_limit, steer_limit);
+    std::clamp(input.lateral.steering_tire_angle, -steer_cmd_limit, steer_cmd_limit);
 }
 
 void VehicleCmdFilter::limitLateralSteerRate(const double dt, Control & input) const
 {
-  const float steer_rate_limit = getSteerRateLim();
-
-  // for steering angle rate
-  input.lateral.steering_tire_rotation_rate =
-    std::clamp(input.lateral.steering_tire_rotation_rate, -steer_rate_limit, steer_rate_limit);
-
-  // for steering angle
-  const float steer_diff_limit = steer_rate_limit * dt;
+  const float cmd_steer_rate_lim = getSteerCmdRateLimForSteerCmdRate();
+
+  // Calculate maximum allowable steering rate based on lateral jerk constraint
+  // Using the formula: j_y = (1/L) * V^2 * (dθ/dt)
+  // Where:
+  // - j_y: lateral jerk
+  // - L: wheel base
+  // - V: longitudinal velocity
+  // - dθ/dt: steering angle rate of change
+  // Rearranging: dθ/dt = j_y * L / V^2
+  const double lat_jerk_lim_for_steer_rate = getLatJerkLimForSteerRate();
+  const double velocity_sq = std::max(current_speed_ * current_speed_, 0.001);
+  const double max_steer_rate_from_jerk =
+    lat_jerk_lim_for_steer_rate * param_.wheel_base / velocity_sq;
+
+  // Apply the more restrictive limit between basic rate limit and lateral jerk constraint
+  const float effective_steer_rate_lim =
+    std::min(static_cast<double>(cmd_steer_rate_lim), max_steer_rate_from_jerk);
+
+  // Limit steering angle rate
+  input.lateral.steering_tire_rotation_rate = std::clamp(
+    input.lateral.steering_tire_rotation_rate, -effective_steer_rate_lim, effective_steer_rate_lim);
+
+  // Limit steering angle change
+  const float steer_diff_limit = effective_steer_rate_lim * dt;
   float ds = input.lateral.steering_tire_angle - prev_cmd_.lateral.steering_tire_angle;
   ds = std::clamp(ds, -steer_diff_limit, steer_diff_limit);
   input.lateral.steering_tire_angle = prev_cmd_.lateral.steering_tire_angle + ds;
@@ -248,33 +269,38 @@ double VehicleCmdFilter::interpolateFromSpeed(const LimitArray & limits) const
   return reference.back();
 }
 
-double VehicleCmdFilter::getLonAccLim() const
+double VehicleCmdFilter::getLonAccLimForLonVel() const
 {
-  return interpolateFromSpeed(param_.lon_acc_lim);
+  return interpolateFromSpeed(param_.lon_acc_lim_for_lon_vel);
 }
-double VehicleCmdFilter::getLonJerkLim() const
+double VehicleCmdFilter::getLonJerkLimForLonAcc() const
 {
-  return interpolateFromSpeed(param_.lon_jerk_lim);
+  return interpolateFromSpeed(param_.lon_jerk_lim_for_lon_acc);
 }
-double VehicleCmdFilter::getLatAccLim() const
+double VehicleCmdFilter::getLatAccLimForSteerCmd() const
 {
-  return interpolateFromSpeed(param_.lat_acc_lim);
+  return interpolateFromSpeed(param_.lat_acc_lim_for_steer_cmd);
 }
-double VehicleCmdFilter::getLatJerkLim() const
+double VehicleCmdFilter::getLatJerkLimForSteerCmd() const
 {
-  return interpolateFromSpeed(param_.lat_jerk_lim);
+  return interpolateFromSpeed(param_.lat_jerk_lim_for_steer_cmd);
 }
-double VehicleCmdFilter::getSteerLim() const
+double VehicleCmdFilter::getSteerCmdLim() const
 {
-  return interpolateFromSpeed(param_.steer_lim);
+  return interpolateFromSpeed(param_.steer_cmd_lim);
 }
-double VehicleCmdFilter::getSteerRateLim() const
+double VehicleCmdFilter::getSteerCmdRateLimForSteerCmdRate() const
 {
-  return interpolateFromSpeed(param_.steer_rate_lim);
+  return interpolateFromSpeed(param_.steer_rate_lim_for_steer_cmd);
 }
-double VehicleCmdFilter::getSteerDiffLim() const
+double VehicleCmdFilter::getSteerCmdDiffLimFromCurrentSteer() const
+{
+  return interpolateFromSpeed(param_.steer_cmd_diff_lim_from_current_steer);
+}
+
+double VehicleCmdFilter::getLatJerkLimForSteerRate() const
 {
-  return interpolateFromSpeed(param_.actual_steer_diff_lim);
+  return param_.lat_jerk_lim_for_steer_rate;
 }
 
 }  // namespace autoware::vehicle_cmd_gate
diff --git a/control/autoware_vehicle_cmd_gate/src/vehicle_cmd_filter.hpp b/control/autoware_vehicle_cmd_gate/src/vehicle_cmd_filter.hpp
index 086d45cf1f..7c951ab654 100644
--- a/control/autoware_vehicle_cmd_gate/src/vehicle_cmd_filter.hpp
+++ b/control/autoware_vehicle_cmd_gate/src/vehicle_cmd_filter.hpp
@@ -33,13 +33,14 @@ struct VehicleCmdFilterParam
   double wheel_base;
   double vel_lim;
   LimitArray reference_speed_points;
-  LimitArray lon_acc_lim;
-  LimitArray lon_jerk_lim;
-  LimitArray lat_acc_lim;
-  LimitArray lat_jerk_lim;
-  LimitArray steer_lim;
-  LimitArray steer_rate_lim;
-  LimitArray actual_steer_diff_lim;
+  LimitArray lon_acc_lim_for_lon_vel;
+  LimitArray lon_jerk_lim_for_lon_acc;
+  LimitArray lat_acc_lim_for_steer_cmd;
+  LimitArray lat_jerk_lim_for_steer_cmd;
+  LimitArray steer_cmd_lim;
+  LimitArray steer_rate_lim_for_steer_cmd;
+  LimitArray steer_cmd_diff_lim_from_current_steer;
+  double lat_jerk_lim_for_steer_rate;
 };
 class VehicleCmdFilter
 {
@@ -80,13 +81,14 @@ private:
   static double limitDiff(const double curr, const double prev, const double diff_lim);
 
   double interpolateFromSpeed(const LimitArray & limits) const;
-  double getLonAccLim() const;
-  double getLonJerkLim() const;
-  double getLatAccLim() const;
-  double getLatJerkLim() const;
-  double getSteerLim() const;
-  double getSteerRateLim() const;
-  double getSteerDiffLim() const;
+  double getLonAccLimForLonVel() const;
+  double getLonJerkLimForLonAcc() const;
+  double getLatAccLimForSteerCmd() const;
+  double getLatJerkLimForSteerCmd() const;
+  double getSteerCmdLim() const;
+  double getSteerCmdRateLimForSteerCmdRate() const;
+  double getSteerCmdDiffLimFromCurrentSteer() const;
+  double getLatJerkLimForSteerRate() const;
 };
 }  // namespace autoware::vehicle_cmd_gate
 
diff --git a/control/autoware_vehicle_cmd_gate/src/vehicle_cmd_gate.cpp b/control/autoware_vehicle_cmd_gate/src/vehicle_cmd_gate.cpp
index 55db485af0..336d4bb23b 100644
--- a/control/autoware_vehicle_cmd_gate/src/vehicle_cmd_gate.cpp
+++ b/control/autoware_vehicle_cmd_gate/src/vehicle_cmd_gate.cpp
@@ -151,14 +151,21 @@ VehicleCmdGate::VehicleCmdGate(const rclcpp::NodeOptions & node_options)
     p.vel_lim = declare_parameter<double>("nominal.vel_lim");
     p.reference_speed_points =
       declare_parameter<std::vector<double>>("nominal.reference_speed_points");
-    p.steer_lim = declare_parameter<std::vector<double>>("nominal.steer_lim");
-    p.steer_rate_lim = declare_parameter<std::vector<double>>("nominal.steer_rate_lim");
-    p.lon_acc_lim = declare_parameter<std::vector<double>>("nominal.lon_acc_lim");
-    p.lon_jerk_lim = declare_parameter<std::vector<double>>("nominal.lon_jerk_lim");
-    p.lat_acc_lim = declare_parameter<std::vector<double>>("nominal.lat_acc_lim");
-    p.lat_jerk_lim = declare_parameter<std::vector<double>>("nominal.lat_jerk_lim");
-    p.actual_steer_diff_lim =
-      declare_parameter<std::vector<double>>("nominal.actual_steer_diff_lim");
+    p.steer_cmd_lim = declare_parameter<std::vector<double>>("nominal.steer_cmd_lim");
+    p.lon_acc_lim_for_lon_vel =
+      declare_parameter<std::vector<double>>("nominal.lon_acc_lim_for_lon_vel");
+    p.lon_jerk_lim_for_lon_acc =
+      declare_parameter<std::vector<double>>("nominal.lon_jerk_lim_for_lon_acc");
+    p.lat_acc_lim_for_steer_cmd =
+      declare_parameter<std::vector<double>>("nominal.lat_acc_lim_for_steer_cmd");
+    p.lat_jerk_lim_for_steer_cmd =
+      declare_parameter<std::vector<double>>("nominal.lat_jerk_lim_for_steer_cmd");
+    p.steer_cmd_diff_lim_from_current_steer =
+      declare_parameter<std::vector<double>>("nominal.steer_cmd_diff_lim_from_current_steer");
+    p.steer_rate_lim_for_steer_cmd =
+      declare_parameter<std::vector<double>>("nominal.steer_rate_lim_for_steer_cmd");
+    p.lat_jerk_lim_for_steer_rate =
+      declare_parameter<double>("nominal.lat_jerk_lim_for_steer_rate");
     filter_.setParam(p);
   }
 
@@ -168,14 +175,21 @@ VehicleCmdGate::VehicleCmdGate(const rclcpp::NodeOptions & node_options)
     p.vel_lim = declare_parameter<double>("on_transition.vel_lim");
     p.reference_speed_points =
       declare_parameter<std::vector<double>>("on_transition.reference_speed_points");
-    p.steer_lim = declare_parameter<std::vector<double>>("on_transition.steer_lim");
-    p.steer_rate_lim = declare_parameter<std::vector<double>>("on_transition.steer_rate_lim");
-    p.lon_acc_lim = declare_parameter<std::vector<double>>("on_transition.lon_acc_lim");
-    p.lon_jerk_lim = declare_parameter<std::vector<double>>("on_transition.lon_jerk_lim");
-    p.lat_acc_lim = declare_parameter<std::vector<double>>("on_transition.lat_acc_lim");
-    p.lat_jerk_lim = declare_parameter<std::vector<double>>("on_transition.lat_jerk_lim");
-    p.actual_steer_diff_lim =
-      declare_parameter<std::vector<double>>("on_transition.actual_steer_diff_lim");
+    p.steer_cmd_lim = declare_parameter<std::vector<double>>("on_transition.steer_cmd_lim");
+    p.lon_acc_lim_for_lon_vel =
+      declare_parameter<std::vector<double>>("on_transition.lon_acc_lim_for_lon_vel");
+    p.lon_jerk_lim_for_lon_acc =
+      declare_parameter<std::vector<double>>("on_transition.lon_jerk_lim_for_lon_acc");
+    p.lat_acc_lim_for_steer_cmd =
+      declare_parameter<std::vector<double>>("on_transition.lat_acc_lim_for_steer_cmd");
+    p.lat_jerk_lim_for_steer_cmd =
+      declare_parameter<std::vector<double>>("on_transition.lat_jerk_lim_for_steer_cmd");
+    p.steer_cmd_diff_lim_from_current_steer =
+      declare_parameter<std::vector<double>>("on_transition.steer_cmd_diff_lim_from_current_steer");
+    p.steer_rate_lim_for_steer_cmd =
+      declare_parameter<std::vector<double>>("on_transition.steer_rate_lim_for_steer_cmd");
+    p.lat_jerk_lim_for_steer_rate =
+      declare_parameter<double>("on_transition.lat_jerk_lim_for_steer_rate");
     filter_on_transition_.setParam(p);
   }
 
@@ -257,14 +271,22 @@ rcl_interfaces::msg::SetParametersResult VehicleCmdGate::onParameter(
     update_param<double>(parameters, "nominal.vel_lim", p.vel_lim);
     update_param<std::vector<double>>(
       parameters, "nominal.reference_speed_points", p.reference_speed_points);
-    update_param<std::vector<double>>(parameters, "nominal.steer_lim", p.steer_lim);
-    update_param<std::vector<double>>(parameters, "nominal.steer_rate_lim", p.steer_rate_lim);
-    update_param<std::vector<double>>(parameters, "nominal.lon_acc_lim", p.lon_acc_lim);
-    update_param<std::vector<double>>(parameters, "nominal.lon_jerk_lim", p.lon_jerk_lim);
-    update_param<std::vector<double>>(parameters, "nominal.lat_acc_lim", p.lat_acc_lim);
-    update_param<std::vector<double>>(parameters, "nominal.lat_jerk_lim", p.lat_jerk_lim);
+    update_param<std::vector<double>>(parameters, "nominal.steer_cmd_lim", p.steer_cmd_lim);
     update_param<std::vector<double>>(
-      parameters, "nominal.actual_steer_diff_lim", p.actual_steer_diff_lim);
+      parameters, "nominal.steer_rate_lim_for_steer_cmd", p.steer_rate_lim_for_steer_cmd);
+    update_param<std::vector<double>>(
+      parameters, "nominal.lon_acc_lim_for_lon_vel", p.lon_acc_lim_for_lon_vel);
+    update_param<std::vector<double>>(
+      parameters, "nominal.lon_jerk_lim_for_lon_acc", p.lon_jerk_lim_for_lon_acc);
+    update_param<std::vector<double>>(
+      parameters, "nominal.lat_acc_lim_for_steer_cmd", p.lat_acc_lim_for_steer_cmd);
+    update_param<std::vector<double>>(
+      parameters, "nominal.lat_jerk_lim_for_steer_cmd", p.lat_jerk_lim_for_steer_cmd);
+    update_param<std::vector<double>>(
+      parameters, "nominal.steer_cmd_diff_lim_from_current_steer",
+      p.steer_cmd_diff_lim_from_current_steer);
+    update_param<double>(
+      parameters, "nominal.lat_jerk_lim_for_steer_rate", p.lat_jerk_lim_for_steer_rate);
     filter_.setParam(p);
   }
 
@@ -274,14 +296,22 @@ rcl_interfaces::msg::SetParametersResult VehicleCmdGate::onParameter(
     update_param<double>(parameters, "on_transition.vel_lim", p.vel_lim);
     update_param<std::vector<double>>(
       parameters, "on_transition.reference_speed_points", p.reference_speed_points);
-    update_param<std::vector<double>>(parameters, "on_transition.steer_lim", p.steer_lim);
-    update_param<std::vector<double>>(parameters, "on_transition.steer_rate_lim", p.steer_rate_lim);
-    update_param<std::vector<double>>(parameters, "on_transition.lon_acc_lim", p.lon_acc_lim);
-    update_param<std::vector<double>>(parameters, "on_transition.lon_jerk_lim", p.lon_jerk_lim);
-    update_param<std::vector<double>>(parameters, "on_transition.lat_acc_lim", p.lat_acc_lim);
-    update_param<std::vector<double>>(parameters, "on_transition.lat_jerk_lim", p.lat_jerk_lim);
+    update_param<std::vector<double>>(parameters, "on_transition.steer_cmd_lim", p.steer_cmd_lim);
+    update_param<std::vector<double>>(
+      parameters, "on_transition.steer_rate_lim_for_steer_cmd", p.steer_rate_lim_for_steer_cmd);
+    update_param<std::vector<double>>(
+      parameters, "on_transition.lon_acc_lim_for_lon_vel", p.lon_acc_lim_for_lon_vel);
+    update_param<std::vector<double>>(
+      parameters, "on_transition.lon_jerk_lim_for_lon_acc", p.lon_jerk_lim_for_lon_acc);
+    update_param<std::vector<double>>(
+      parameters, "on_transition.lat_acc_lim_for_steer_cmd", p.lat_acc_lim_for_steer_cmd);
+    update_param<std::vector<double>>(
+      parameters, "on_transition.lat_jerk_lim_for_steer_cmd", p.lat_jerk_lim_for_steer_cmd);
     update_param<std::vector<double>>(
-      parameters, "on_transition.actual_steer_diff_lim", p.actual_steer_diff_lim);
+      parameters, "on_transition.steer_cmd_diff_lim_from_current_steer",
+      p.steer_cmd_diff_lim_from_current_steer);
+    update_param<double>(
+      parameters, "on_transition.lat_jerk_lim_for_steer_rate", p.lat_jerk_lim_for_steer_rate);
     filter_on_transition_.setParam(p);
   }
 
diff --git a/control/autoware_vehicle_cmd_gate/test/src/test_filter_in_vehicle_cmd_gate_node.cpp b/control/autoware_vehicle_cmd_gate/test/src/test_filter_in_vehicle_cmd_gate_node.cpp
index b300b10a44..382a06dbef 100644
--- a/control/autoware_vehicle_cmd_gate/test/src/test_filter_in_vehicle_cmd_gate_node.cpp
+++ b/control/autoware_vehicle_cmd_gate/test/src/test_filter_in_vehicle_cmd_gate_node.cpp
@@ -47,13 +47,13 @@ void print_values(int i, const T1 & name, const T2 & a, const T3 &... b)
 
 // global params
 const std::vector<double> reference_speed_points = {5., 10., 15., 20.};
-const std::vector<double> steer_lim = {0.5, 0.3, 0.2, 0.1};
-const std::vector<double> steer_rate_lim = {0.5, 0.3, 0.2, 0.1};
-const std::vector<double> lon_acc_lim = {1.5, 1.0, 0.8, 0.6};
-const std::vector<double> lon_jerk_lim = {1.4, 0.9, 0.7, 0.5};
-const std::vector<double> lat_acc_lim = {2.0, 1.6, 1.2, 0.8};
-const std::vector<double> lat_jerk_lim = {1.7, 1.3, 0.9, 0.6};
-const std::vector<double> actual_steer_diff_lim = {0.5, 0.4, 0.2, 0.1};
+const std::vector<double> steer_cmd_lim = {0.5, 0.3, 0.2, 0.1};
+const std::vector<double> steer_rate_lim_for_steer_cmd = {0.5, 0.3, 0.2, 0.1};
+const std::vector<double> lon_acc_lim_for_lon_vel = {1.5, 1.0, 0.8, 0.6};
+const std::vector<double> lon_jerk_lim_for_lon_acc = {1.4, 0.9, 0.7, 0.5};
+const std::vector<double> lat_acc_lim_for_steer_cmd = {2.0, 1.6, 1.2, 0.8};
+const std::vector<double> lat_jerk_lim_for_steer_cmd = {1.7, 1.3, 0.9, 0.6};
+const std::vector<double> steer_cmd_diff_lim_from_current_steer = {0.5, 0.4, 0.2, 0.1};
 const double wheelbase = 2.89;
 
 using autoware::vehicle_cmd_gate::VehicleCmdGate;
@@ -291,10 +291,14 @@ public:
     avg_lat_acc /= denominator;
     avg_lat_jerk /= denominator;
 
-    const auto max_lon_acc_lim = *std::max_element(lon_acc_lim.begin(), lon_acc_lim.end());
-    const auto max_lon_jerk_lim = *std::max_element(lon_jerk_lim.begin(), lon_jerk_lim.end());
-    const auto max_lat_acc_lim = *std::max_element(lat_acc_lim.begin(), lat_acc_lim.end());
-    const auto max_lat_jerk_lim = *std::max_element(lat_jerk_lim.begin(), lat_jerk_lim.end());
+    const auto max_lon_acc_lim =
+      *std::max_element(lon_acc_lim_for_lon_vel.begin(), lon_acc_lim_for_lon_vel.end());
+    const auto max_lon_jerk_lim =
+      *std::max_element(lon_jerk_lim_for_lon_acc.begin(), lon_jerk_lim_for_lon_acc.end());
+    const auto max_lat_acc_lim =
+      *std::max_element(lat_acc_lim_for_steer_cmd.begin(), lat_acc_lim_for_steer_cmd.end());
+    const auto max_lat_jerk_lim =
+      *std::max_element(lat_jerk_lim_for_steer_cmd.begin(), lat_jerk_lim_for_steer_cmd.end());
 
     // This test is designed to verify that the filter is applied correctly. However, if topic
     // communication is delayed, the allowable range of change in the command values between the
@@ -393,14 +397,13 @@ std::shared_ptr<VehicleCmdGate> generateNode()
 
   node_options.append_parameter_override("wheel_base", wheelbase);
   override("nominal.reference_speed_points", reference_speed_points);
-  override("nominal.reference_speed_points", reference_speed_points);
-  override("nominal.steer_lim", steer_lim);
-  override("nominal.steer_rate_lim", steer_rate_lim);
-  override("nominal.lon_acc_lim", lon_acc_lim);
-  override("nominal.lon_jerk_lim", lon_jerk_lim);
-  override("nominal.lat_acc_lim", lat_acc_lim);
-  override("nominal.lat_jerk_lim", lat_jerk_lim);
-  override("nominal.actual_steer_diff_lim", actual_steer_diff_lim);
+  override("nominal.steer_cmd_lim", steer_cmd_lim);
+  override("nominal.steer_rate_lim_for_steer_cmd", steer_rate_lim_for_steer_cmd);
+  override("nominal.lon_acc_lim_for_lon_vel", lon_acc_lim_for_lon_vel);
+  override("nominal.lon_jerk_lim_for_lon_acc", lon_jerk_lim_for_lon_acc);
+  override("nominal.lat_acc_lim_for_steer_cmd", lat_acc_lim_for_steer_cmd);
+  override("nominal.lat_jerk_lim_for_steer_cmd", lat_jerk_lim_for_steer_cmd);
+  override("nominal.steer_cmd_diff_lim_from_current_steer", steer_cmd_diff_lim_from_current_steer);
 
   return std::make_shared<VehicleCmdGate>(node_options);
 }
diff --git a/control/autoware_vehicle_cmd_gate/test/src/test_vehicle_cmd_filter.cpp b/control/autoware_vehicle_cmd_gate/test/src/test_vehicle_cmd_filter.cpp
index 528253671b..b3c7c9a974 100644
--- a/control/autoware_vehicle_cmd_gate/test/src/test_vehicle_cmd_filter.cpp
+++ b/control/autoware_vehicle_cmd_gate/test/src/test_vehicle_cmd_filter.cpp
@@ -16,6 +16,7 @@
 
 #include <gtest/gtest.h>
 
+#include <algorithm>
 #include <cmath>
 #include <string>
 #include <vector>
@@ -32,19 +33,20 @@ constexpr double NOMINAL_INTERVAL = 1.0;
 void setFilterParams(
   autoware::vehicle_cmd_gate::VehicleCmdFilter & f, double v, LimitArray speed_points, LimitArray a,
   LimitArray j, LimitArray lat_a, LimitArray lat_j, LimitArray steer_diff, LimitArray steer_lim,
-  LimitArray steer_rate_lim, const double wheelbase)
+  LimitArray steer_cmd_rate_lim, const double wheelbase, const double lat_jerk_lim_for_steer_rate)
 {
   autoware::vehicle_cmd_gate::VehicleCmdFilterParam p;
   p.vel_lim = v;
   p.wheel_base = wheelbase;
   p.reference_speed_points = speed_points;
-  p.steer_lim = steer_lim;
-  p.steer_rate_lim = steer_rate_lim;
-  p.lat_acc_lim = lat_a;
-  p.lat_jerk_lim = lat_j;
-  p.lon_acc_lim = a;
-  p.lon_jerk_lim = j;
-  p.actual_steer_diff_lim = steer_diff;
+  p.steer_cmd_lim = steer_lim;
+  p.steer_rate_lim_for_steer_cmd = steer_cmd_rate_lim;
+  p.lat_acc_lim_for_steer_cmd = lat_a;
+  p.lat_jerk_lim_for_steer_cmd = lat_j;
+  p.lon_acc_lim_for_lon_vel = a;
+  p.lon_jerk_lim_for_lon_acc = j;
+  p.steer_cmd_diff_lim_from_current_steer = steer_diff;
+  p.lat_jerk_lim_for_steer_rate = lat_jerk_lim_for_steer_rate;
 
   f.setParam(p);
 }
@@ -99,8 +101,8 @@ double calcLatJerk(
 
 void test_1d_limit(
   double ego_v, double V_LIM, double A_LIM, double J_LIM, double LAT_A_LIM, double LAT_J_LIM,
-  double STEER_DIFF, double STEER_LIM, double STEER_RATE_LIM, const Control & prev_cmd,
-  const Control & raw_cmd)
+  double STEER_DIFF, double STEER_LIM, double STEER_RATE_LIM, double LAT_JERK_LIM_FOR_STEER_RATE,
+  const Control & prev_cmd, const Control & raw_cmd)
 {
   const double WHEELBASE = 3.0;
   const double DT = 0.1;  // [s]
@@ -109,7 +111,7 @@ void test_1d_limit(
   filter.setCurrentSpeed(ego_v);
   setFilterParams(
     filter, V_LIM, {0.0}, {A_LIM}, {J_LIM}, {LAT_A_LIM}, {LAT_J_LIM}, {STEER_DIFF}, {STEER_LIM},
-    {STEER_RATE_LIM}, WHEELBASE);
+    {STEER_RATE_LIM}, WHEELBASE, LAT_JERK_LIM_FOR_STEER_RATE);
   filter.setPrevCmd(prev_cmd);
 
   // velocity filter
@@ -226,6 +228,40 @@ void test_1d_limit(
         filtered_cmd.lateral.steering_tire_angle, raw_cmd.lateral.steering_tire_angle, THRESHOLD);
     }
   }
+
+  // steering rate filter with lateral jerk constraint
+  {
+    auto filtered_cmd = raw_cmd;
+    filter.limitLateralSteerRate(DT, filtered_cmd);
+
+    // Calculate the effective steering rate limit considering lateral jerk constraint
+    const double velocity_sq = std::max(ego_v * ego_v, 0.001);
+    const double max_steer_rate_from_jerk = LAT_JERK_LIM_FOR_STEER_RATE * WHEELBASE / velocity_sq;
+    const double effective_steer_rate_lim = std::min(STEER_RATE_LIM, max_steer_rate_from_jerk);
+
+    // Check steering angle rate limit
+    ASSERT_LT_NEAR(
+      std::abs(filtered_cmd.lateral.steering_tire_rotation_rate), effective_steer_rate_lim);
+
+    // Check steering angle change limit
+    const double steer_diff_limit = effective_steer_rate_lim * DT;
+    const double filtered_steer_diff =
+      filtered_cmd.lateral.steering_tire_angle - prev_cmd.lateral.steering_tire_angle;
+    ASSERT_LT_NEAR(std::abs(filtered_steer_diff), steer_diff_limit);
+
+    // Check if the undesired filter is not applied when within limits
+    const double raw_steer_diff =
+      raw_cmd.lateral.steering_tire_angle - prev_cmd.lateral.steering_tire_angle;
+    if (
+      std::abs(raw_steer_diff) < steer_diff_limit &&
+      std::abs(raw_cmd.lateral.steering_tire_rotation_rate) < effective_steer_rate_lim) {
+      ASSERT_NEAR(
+        filtered_cmd.lateral.steering_tire_angle, raw_cmd.lateral.steering_tire_angle, THRESHOLD);
+      ASSERT_NEAR(
+        filtered_cmd.lateral.steering_tire_rotation_rate,
+        raw_cmd.lateral.steering_tire_rotation_rate, THRESHOLD);
+    }
+  }
 }
 
 TEST(VehicleCmdFilter, VehicleCmdFilter)
@@ -238,6 +274,7 @@ TEST(VehicleCmdFilter, VehicleCmdFilter)
   const std::vector<double> steer_diff_arr = {0.01, 1.0, 100.0};
   const std::vector<double> steer_lim_arr = {0.01, 1.0, 100.0};
   const std::vector<double> steer_rate_lim_arr = {0.01, 1.0, 100.0};
+  const std::vector<double> lat_jerk_lim_for_steer_rate_arr = {0.01, 1.0, 10.0};
   const std::vector<double> ego_v_arr = {0.0, 0.1, 1.0, 3.0, 15.0};
 
   const std::vector<Control> prev_cmd_arr = {
@@ -256,9 +293,13 @@ TEST(VehicleCmdFilter, VehicleCmdFilter)
                 for (const auto & steer_diff : steer_diff_arr) {
                   for (const auto & steer : steer_lim_arr) {
                     for (const auto & steer_rate : steer_rate_lim_arr) {
-                      for (const auto & ego_v : ego_v_arr) {
-                        test_1d_limit(
-                          ego_v, v, a, j, la, lj, steer_diff, steer, steer_rate, prev_cmd, raw_cmd);
+                      for (const auto & lat_jerk_lim_for_steer_rate :
+                           lat_jerk_lim_for_steer_rate_arr) {
+                        for (const auto & ego_v : ego_v_arr) {
+                          test_1d_limit(
+                            ego_v, v, a, j, la, lj, steer_diff, steer, steer_rate,
+                            lat_jerk_lim_for_steer_rate, prev_cmd, raw_cmd);
+                        }
                       }
                     }
                   }
@@ -281,13 +322,14 @@ TEST(VehicleCmdFilter, VehicleCmdFilterInterpolate)
   p.wheel_base = WHEELBASE;
   p.vel_lim = 20.0;
   p.reference_speed_points = std::vector<double>{2.0, 4.0, 10.0};
-  p.steer_lim = std::vector<double>{0.1, 0.2, 0.3};
-  p.steer_rate_lim = std::vector<double>{0.2, 0.1, 0.05};
-  p.lon_acc_lim = std::vector<double>{0.3, 0.4, 0.5};
-  p.lon_jerk_lim = std::vector<double>{0.4, 0.4, 0.7};
-  p.lat_acc_lim = std::vector<double>{0.1, 0.2, 0.3};
-  p.lat_jerk_lim = std::vector<double>{0.9, 0.7, 0.1};
-  p.actual_steer_diff_lim = std::vector<double>{0.1, 0.3, 0.2};
+  p.steer_cmd_lim = std::vector<double>{0.1, 0.2, 0.3};
+  p.steer_rate_lim_for_steer_cmd = std::vector<double>{0.2, 0.1, 0.05};
+  p.lon_acc_lim_for_lon_vel = std::vector<double>{0.3, 0.4, 0.5};
+  p.lon_jerk_lim_for_lon_acc = std::vector<double>{0.4, 0.4, 0.7};
+  p.lat_acc_lim_for_steer_cmd = std::vector<double>{0.1, 0.2, 0.3};
+  p.lat_jerk_lim_for_steer_cmd = std::vector<double>{0.9, 0.7, 0.1};
+  p.steer_cmd_diff_lim_from_current_steer = std::vector<double>{0.1, 0.3, 0.2};
+  p.lat_jerk_lim_for_steer_rate = 5.0;
   filter.setParam(p);
 
   const auto DT = 0.033;
@@ -383,7 +425,7 @@ TEST(VehicleCmdFilter, VehicleCmdFilterInterpolate)
 
   // steer angle rate lim
   // p.reference_speed_points = std::vector<double>{2.0, 4.0, 10.0};
-  // p.steer_rate_lim = std::vector<double>{0.2, 0.1, 0.05};
+  // p.cmd_steer_rate_lim = std::vector<double>{0.2, 0.1, 0.05};
   {
     const auto calcSteerRateFromAngle = [&](const auto & cmd) {
       return (cmd.steering_tire_angle - 0.0) / DT;
@@ -583,4 +625,16 @@ TEST(VehicleCmdFilter, VehicleCmdFilterInterpolate)
     set_speed_and_reset_prev(15.0);
     EXPECT_NEAR((_limitActualSteerDiff(orig_cmd).lateral.steering_tire_angle), 0.2, ep);
   }
+
+  // lat_jerk_lim_for_steer_rate test
+  // This parameter is used in limitLateralSteerRate function to calculate lateral jerk constraint
+  {
+    // Test that the parameter is correctly set and retrieved
+    EXPECT_NEAR(filter.getParam().lat_jerk_lim_for_steer_rate, 5.0, ep);
+
+    // Test that the function returns the correct value
+    // Note: This tests the getLatJerkLimForSteerRate() function
+    // The actual filtering logic is tested in the steering rate filter test above
+    EXPECT_NEAR(filter.getParam().lat_jerk_lim_for_steer_rate, 5.0, ep);
+  }
 }
