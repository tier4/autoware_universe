# Trajectory Follower

これは`trajectory_follower`パッケージの設計文書です。

## 目的/ユースケース

<!-- Required -->
<!-- Things to consider:
    - Why did we implement this feature? -->

このパッケージは`autoware_trajectory_follower_node`パッケージのノードによって使用される縦横コントローラのインターフェイスを提供します。縦横の基本インターフェイスを派生させることで詳細なコントローラを実装できます。

## 設計

インターフェイスクラスとそれぞれから派生したアルゴリズムの縦横の基本インターフェイスクラスがあります。インターフェイスクラスにはベース関数がいくつかあります。

- `isReady()`: 制御が計算できるかどうかを確認します。
- `run()`: 制御コマンドを計算して[Trajectory Follower Nodes](../autoware_trajectory_follower_node/README.md)に戻します。継承したアルゴリズムによって実装する必要があります。
- `sync()`: 別のコントローラの実行結果を入力します。
  - ステアリング角度の収束
    - ステアリングの収束を待つまで停止を維持できます。
  - 速度の収束(現在使用されていません)

ノード内でこれらの関数がどのように機能するかについては[Trajectory Follower ノードの設計](../autoware_trajectory_follower_node/README.md#Design)を参照してください。

## 分離された横(ステアリング)および縦(速度)制御

この縦横コントローラは、横と縦の役割が次のように分離されていると仮定しています。

- 横の制御は、速度追従が完璧だと仮定して、車両を軌道上にとどめるための目標ステアリングを計算します。
- 縦の制御は、軌道追従が完璧だと仮定して、車両の速度を目標の軌道速度で維持するための目標速度/加速度を計算します。

理想的には、横と縦の制御を単一の混合問題として扱うことで高いパフォーマンスを実現できます。対して、Velocity Controllerをスタンドアロン関数として提供する理由は次の2つです。

### 縦方向の動作に対する複雑な要件

人間が期待する縦方向の車両の挙動は、単一のロジックで表現するのが困難です。たとえば、停止直前の期待される挙動は、自車位置が停止線の前/後ろにあるか、および人間らしい動きを実現するために現在の速度が達成する目標速度よりも高いか低いかによって異なります。

さらに、一部の車両は極低速では自車速度の測定が困難です。そのような場合、横の制御に影響を与えずに縦の制御機能を向上させる構成が重要です。

縦の制御には独自の特性とニーズが数多くあります。横の制御とは別に設計することで、モジュールの結合が少なくなり、保守性が向上します。

### 横と縦の動きの非線形結合

横縦混合制御問題は非常に複雑で、高いパフォーマンスを実現するために非線形最適化を使用しています。非線形最適化の収束を保証することは困難であるため、開発にはシンプルな制御ロジックも必要です。

また、車両の速度があまり速くない場合、同時縦横制御のメリットは小さくなります。

## 関連する課題

<!-- Required -->

