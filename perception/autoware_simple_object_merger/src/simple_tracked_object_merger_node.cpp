// Copyright 2025 TIER IV, Inc.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

#include "autoware/simple_object_merger/simple_tracked_object_merger_node.hpp"

#include <geometry_msgs/msg/pose_stamped.hpp>

#include <boost/uuid/uuid.hpp>
#include <boost/uuid/uuid_generators.hpp>
#include <boost/uuid/uuid_io.hpp>

#include <algorithm>
#include <chrono>
#include <memory>
#include <stdexcept>
#include <string>
#include <unordered_map>
#include <vector>

namespace autoware::simple_object_merger
{
using namespace std::literals;
using std::chrono::duration;
using std::chrono::duration_cast;
using std::chrono::nanoseconds;

std::string uuidToString(const unique_identifier_msgs::msg::UUID & uuid)
{
  std::ostringstream oss;
  for (size_t i = 0; i < uuid.uuid.size(); ++i) {
    oss << std::hex << std::setw(2) << std::setfill('0') << static_cast<int>(uuid.uuid[i]);
  }

  return oss.str();
}

unique_identifier_msgs::msg::UUID generateNewUUID()
{
  static boost::uuids::random_generator generator;
  boost::uuids::uuid boost_uuid = generator();

  unique_identifier_msgs::msg::UUID uuid;
  std::copy(boost_uuid.begin(), boost_uuid.end(), uuid.uuid.begin());

  return uuid;
}

unique_identifier_msgs::msg::UUID generateUUID()
{
  static boost::uuids::random_generator generator;
  boost::uuids::uuid boost_uuid = generator();

  unique_identifier_msgs::msg::UUID uuid;
  std::copy(boost_uuid.begin(), boost_uuid.end(), uuid.uuid.begin());

  return uuid;
}

// NOTE: UUIDs generated by Boost's random_generator are unlikely to collide.
//       If optimization is needed, this check could be removed.
void generateNewUUID(
  const std::unordered_map<std::string, UUIDMapping> & mapper,
  unique_identifier_msgs::msg::UUID & new_uuid, std::string & uuid_str)
{
  new_uuid = generateUUID();
  uuid_str = uuidToString(new_uuid);
  // ensure UUID does not collide
  while (mapper.find(uuid_str) != mapper.end()) {
    new_uuid = generateUUID();
    uuid_str = uuidToString(new_uuid);
  }
}

SimpleTrackedObjectMergerNode::SimpleTrackedObjectMergerNode(
  const rclcpp::NodeOptions & node_options)
: SimpleObjectMergerBase<TrackedObjects>("simple_tracked_object_merger", node_options)
{
  uuid_mapping_cleanup_threshold_ =
    rclcpp::Duration::from_seconds(declare_parameter<float>("uuid_mapping_cleanup_threshold"));
}

void SimpleTrackedObjectMergerNode::approximateMerger(
  const TrackedObjects::ConstSharedPtr & object_msg0,
  const TrackedObjects::ConstSharedPtr & object_msg1)
{
  transform_ = transform_listener_->get_transform(
    node_param_.new_frame_id, object_msg0->header.frame_id, object_msg0->header.stamp,
    rclcpp::Duration::from_seconds(0.01));
  TrackedObjects::SharedPtr transformed_objects0 =
    getTransformedObjects(object_msg0, node_param_.new_frame_id, transform_);

  transform_ = transform_listener_->get_transform(
    node_param_.new_frame_id, object_msg1->header.frame_id, object_msg1->header.stamp,
    rclcpp::Duration::from_seconds(0.01));
  TrackedObjects::SharedPtr transformed_objects1 =
    getTransformedObjects(object_msg1, node_param_.new_frame_id, transform_);

  TrackedObjects output_objects;
  output_objects.header = object_msg0->header;
  output_objects.header.frame_id = node_param_.new_frame_id;
  output_objects.objects.reserve(
    transformed_objects0->objects.size() + transformed_objects1->objects.size());

  for (auto & object : transformed_objects0->objects) {
    mapUUID(object, 0);
    output_objects.objects.push_back(object);
  }

  for (auto & object : transformed_objects1->objects) {
    mapUUID(object, 1);
    output_objects.objects.push_back(object);
  }

  pub_objects_->publish(output_objects);
  cleanupUUIDMap();
}

void SimpleTrackedObjectMergerNode::onTimer()
{
  if (!isDataReady()) {
    return;
  }

  TrackedObjects output_objects;
  output_objects.header = objects_data_.at(0)->header;
  output_objects.header.frame_id = node_param_.new_frame_id;

  constexpr double throttle_interval = 3.0;  // seconds
  const rclcpp::Time now = this->now();

  static std::vector<rclcpp::Time> last_log_times;
  if (last_log_times.size() != input_topic_size_) {
    last_log_times.assign(input_topic_size_, now);
  }

  for (size_t i = 0; i < input_topic_size_; i++) {
    double time_diff = rclcpp::Time(objects_data_.at(i)->header.stamp).seconds() -
                       rclcpp::Time(objects_data_.at(0)->header.stamp).seconds();
    if (std::abs(time_diff) < node_param_.timeout_threshold) {
      transform_ = transform_listener_->get_transform(
        node_param_.new_frame_id, objects_data_.at(i)->header.frame_id,
        objects_data_.at(i)->header.stamp, rclcpp::Duration::from_seconds(0.01));

      typename TrackedObjects::SharedPtr transformed_objects =
        getTransformedObjects(objects_data_.at(i), node_param_.new_frame_id, transform_);

      for (auto & object : transformed_objects->objects) {
        mapUUID(object, i);
        output_objects.objects.push_back(object);
      }

    } else if (shouldLogThrottle(i, now, last_log_times, throttle_interval)) {
      RCLCPP_INFO(
        get_logger(), "Topic of %s is timeout by %f sec", node_param_.topic_names.at(i).c_str(),
        time_diff);
    }
  }

  pub_objects_->publish(output_objects);
  cleanupUUIDMap();
}

void SimpleTrackedObjectMergerNode::mapUUID(TrackedObject & object, const int & node_id)
{
  rclcpp::Time now = this->now();

  UUIDMapping & mapping = uuid_mapper_[uuidToString(object.object_id)];
  mapping.last_seen = now;

  // check whether the UUID collides or not.
  if (mapping.pass_through_node_id == -1) {
    // first time of seeing the UUID, no UUID change
    mapping.pass_through_node_id = node_id;
  } else if (mapping.pass_through_node_id == node_id && !mapping.is_mapped_uuid) {
    // when the UUID originate from the node and it is not mapped
    // nothing to do
    ;
  } else {
    // UUID collides
    auto it = mapping.replace_map.find(node_id);
    if (it == mapping.replace_map.end()) {
      unique_identifier_msgs::msg::UUID new_uuid;
      std::string uuid_str;
      generateNewUUID(uuid_mapper_, new_uuid, uuid_str);

      // add the new UUID to the mapper
      UUIDMapping & new_uuid_mapping = uuid_mapper_[uuid_str];
      new_uuid_mapping.pass_through_node_id = node_id;
      new_uuid_mapping.last_seen = now;
      new_uuid_mapping.is_mapped_uuid = true;

      mapping.replace_map[node_id] = new_uuid;
      object.object_id = new_uuid;
    } else {
      object.object_id = it->second;
    }
  }
}

void SimpleTrackedObjectMergerNode::cleanupUUIDMap()
{
  rclcpp::Time now = this->now();

  for (auto it = uuid_mapper_.begin(); it != uuid_mapper_.end();) {
    if ((now - it->second.last_seen) > uuid_mapping_cleanup_threshold_) {
      it = uuid_mapper_.erase(it);
    } else {
      ++it;
    }
  }
}

}  // namespace autoware::simple_object_merger

#include "rclcpp_components/register_node_macro.hpp"
RCLCPP_COMPONENTS_REGISTER_NODE(autoware::simple_object_merger::SimpleTrackedObjectMergerNode)
